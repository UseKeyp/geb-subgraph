# --- Safes & Users ---

type Safe @entity {
  " Equals to: <safeHandler>-<CollateralType> "
  id: ID!

  " Safe ID if this Safe was created through the manager (GebSafeManager) "
  safeId: BigInt

  " Collateral type associated to this safe "
  collateralType: CollateralType!

  " Assets locked as collateral (safeCollateral) "
  collateral: BigDecimal!

  " Outstanding debt "
  debt: BigDecimal!

  " safeHandler address (ownership at the SAFEEngine level) "
  safeHandler: Bytes!

  " Address of Safe owner (top level ownership)"
  owner: User!

  " Optional, address of the proxy if the owner is using a proxy "
  proxy: UserProxy

  " Timestamp of the block in which this Safe was opened [seconds] "
  createdAt: BigInt!

  " Block number in which this Safe was opened "
  createdAtBlock: BigInt!

  " Transaction hash in which this Safe was opened "
  createdAtTransaction: Bytes!

  " Timestamp of the block in which this Safe was last modified [seconds] "
  modifiedAt: BigInt

  " Block number in which this Safe was last modified "
  modifiedAtBlock: BigInt

  " Transaction hash in which this Safe was last modified "
  modifiedAtTransaction: Bytes

  " List of changes in collateralization "
  modifySAFECollateralization: [ModifySAFECollateralization!] @derivedFrom(field: "safe")

  " English Liquidations auctions of the safe "
  liquidationFixedDiscount: [FixDiscountAuction!] @derivedFrom(field: "safe")

  " English Liquidations auctions of the safe "
  liquidationEnglish: [EnglishAuction!] @derivedFrom(field: "safe")
}

type User @entity {
  # End user of the system listing its Safes, balances, proxies, etc...

  " Account address "
  id: ID!

  " Account address "
  address: Bytes!

  " Up to one per collateral type"
  proxies: [UserProxy!] @derivedFrom(field: "owner")

  " Safe owned "
  safes: [Safe!] @derivedFrom(field: "owner")

  " List of collateral balances "
  collateralBalance: [InternalCollateralBalance!] @derivedFrom(field: "owner")

  " List of bonds balances "
  bondBalance: [InternalBondBalance!] @derivedFrom(field: "owner")

  " List of debt balances "
  debtBalance: [InternalDebtBalance!] @derivedFrom(field: "owner")

  " List of collateral deposits made into the system "
  collateralJoin: CollateralJoin @derivedFrom(field: "owner")

  " List of collateral withdrawals made into the system "
  collateralExit: CollateralExit @derivedFrom(field: "owner")

  " List of bond deposits made into the system "
  coinJoin: CoinJoin @derivedFrom(field: "owner")

  " List of bond withdrawals made into the system "
  coinExit: CoinExit @derivedFrom(field: "owner")
}

type UserProxy @entity {
  " Proxy address "
  id: ID!

  " Proxy contract address "
  address: Bytes!

  " Cache contract address "
  cache: Bytes!

  " User reference "
  owner: User!
}

type SafeHandlerOwner @entity {
  # To lookup the owner of a safeHandler, only for managed Safes

  " SafeHandler address "
  id: ID!

  " Owner of the safeHandler address (If owned by a proxy this will be the proxy's owner)"
  owner: User!
}

type ModifySAFECollateralization @entity {
  "<TX hash>-<Log index>"
  id: ID!

  " Safe modified "
  safe: Safe!

  " safeHandler address (ownership at the SAFEEngine level) "
  safeHandler: Bytes!

  " Collateral type of the modification "
  collateralType: CollateralType!

  " Change in collateral "
  deltaCollateral: BigDecimal!

  " Change in debt "
  deltaDebt: BigDecimal!

  " Timestamp of the block in which this Safe was opened [seconds] "
  createdAt: BigInt!

  " Block number in which this Safe was opened "
  createdAtBlock: BigInt!

  " Transaction hash in which this Safe was opened "
  createdAtTransaction: Bytes!
}

# --- System state --

type CollateralType @entity {
  " Collateral type name "
  id: ID!

  " Debt ceiling [bond] (line) "
  debtCeiling: BigDecimal!

  " Min debt per Safe [bond] "
  debtFloor: BigDecimal!

  " Current market price [USD] "
  currentPrice: CollateralPrice

  " Asset/bonds exchange rate (rate), interest accrued on this collateral type "
  accumulatedRate: BigDecimal!

  " Total debt backed by this collateral type [bonds]"
  debtAmount: BigDecimal!

  " collateral price with safety margin. Used to limit the amount of debt that can be generated per one unit of collateral "
  safetyCRatio: BigDecimal!

  " Collateral price with safety margin. Used only in LiquidationEngine when a Safe is liquidated "
  liquidationCRatio: BigDecimal!

  " OSM contract address for the colateral (price source)"
  osmAddress: Bytes

  " Stability fee rate per second for the collateral "
  stabilityFee: BigDecimal!

  " Time of the last stability fee update "
  stabilityFeeLastUpdatedAt: BigInt!

  " Number of Safe NOT opened through the manager (SafeManager) "
  unmanagedSafeCount: BigInt!

  " Number of Safes opened through the manager (SafeManager) "
  safeCount: BigInt!

  " Penalty applied to every liquidation involving this collateral type "
  liquidationPenalty: BigDecimal!

  " Address of the liquidation auction smart contract "
  collateralAuctionHouseAddress: Bytes!

  " Type of collateral auction "
  auctionType: AuctionType

  " Max amount of system coins to request in one auction (If a safe is bigger than this it will be splitted in several auctions) "
  liquidationQuantity: BigDecimal

  " Auction configuration (Fix discount auction only) "
  englishAuctionConfiguration: EnglishAuctionConfiguration

  " Auction configuration (English auction only) "
  fixDiscountAuctionConfiguration: FixDiscountAuctionConfiguration

  " Timestamp of the block in which this collateral type was added [seconds] "
  createdAt: BigInt!

  " Block number in which this collateral type was added "
  createdAtBlock: BigInt!

  " Transaction hash in which this collateral type was added "
  createdAtTransaction: Bytes!

  " Timestamp of the block in which this collateral type was last modified [seconds] "
  modifiedAt: BigInt

  " Block number in which this collateral type was last modified "
  modifiedAtBlock: BigInt

  " Transaction hash in which this collateral type was last modified "
  modifiedAtTransaction: Bytes
}

type SystemState @entity {
  " Singleton entity. Equals to 'current' "
  id: ID!

  " Number of Safes opened through the manager (SafeManager) "
  safeCount: BigInt!

  " Number of Safes NOT opened through the manager (SafeManager) "
  unmanagedSafeCount: BigInt!

  " Total number of Safes with collateral > 0 or debt > 0"
  totalActiveSafeCount: BigInt!

  " Number of user proxies created "
  proxyCount: BigInt!

  " Total debt issued in bonds across all collaterals "
  globalDebt: BigDecimal!

  " Total unbacked debt issued in bonds across all collaterals "
  globalUnbackedDebt: BigDecimal!

  " Total global Debt Ceiling "
  globalDebtCeiling: BigDecimal!

  " Number of collateral types registered "
  collateralCount: BigInt!

  " Base rate for stability fee per second add for all collaterals "
  globalStabilityFee: BigDecimal!

  " Savings Rate "
  savingsRate: BigDecimal!

  " Number of collateral auctions started "
  collateralAuctionCount: BigInt!

  " Latest redemption rate"
  currentRedemptionRate: RedemptionRate

  " Latest redemption price "
  currentRedemptionPrice: RedemptionPrice

  " Timestamp of the block in which the system was created [seconds] "
  createdAt: BigInt!

  " Block number in which the system was created "
  createdAtBlock: BigInt!

  " Transaction hash in which the system was created "
  createdAtTransaction: Bytes!

  " Timestamp of the block in which the system was last modified [seconds] "
  modifiedAt: BigInt

  " Block number in which the system was last modified "
  modifiedAtBlock: BigInt

  " Transaction hash in which the system was last modified "
  modifiedAtTransaction: Bytes

  # TODO: Flap and flop auctions parameters used to be here. Add the auction abstraction class.
}

type AccountingEngine @entity {
  " current "
  id: ID!

  " Total debt in the queue (that the system tries to cover with collateral auctions) "
  totalQueuedDebt: BigDecimal!

  " Total debt being auctioned in DebtAuctionHouse (printing protocol tokens for coins that will settle the debt) "
  totalOnAuctionDebt: BigDecimal!

  " When the last surplus auction was triggered; enforces a delay in case we use DEX surplus auctions "
  lastSurplusAuctionTime: BigInt

  " Delay between surplus auctions "
  surplusAuctionDelay: BigInt!

  " Delay after which debt can be popped from debtQueue "
  popDebtDelay: BigInt!

  " Amount of protocol tokens to be minted post-auction "
  initialDebtAuctionMintedTokens: BigDecimal!

  " Amount of debt sold in one debt auction (initial coin bid for initialDebtAuctionMintedTokens protocol tokens) "
  debtAuctionBidSize: BigDecimal!

  " Amount of surplus stability fees sold in one surplus auction "
  surplusAuctionAmountToSell: BigDecimal!

  " Amount of stability fees that need to accrue in this contract before any surplus auction can start "
  surplusBuffer: BigDecimal!

  " Time to wait (post settlement) until any remaining surpluscan be transferred to the settlement auctioneer "
  disableCooldown: BigInt!

  " When the contract was disabled "
  disableTimestamp: BigInt

  " Whether this contract is enabled or not "
  contractEnabled: Boolean!

  " Safe database "
  safeEngine: Bytes!

  " Contract that handles auctions for surplus stability fees (sell coins for protocol tokens that are then burned) "
  surplusAuctionHouse: Bytes!

  " Contract that handles auctions for debt that couldn't be covered by collateral auctions (it prints protocol tokens in exchange for coins that will settle the debt) "
  debtAuctionHouse: Bytes!

  " Permissions registry for who can burn and mint protocol tokens "
  protocolTokenAuthority: Bytes!

  " Contract that auctions extra surplus after settlement is triggered "
  postSettlementSurplusDrain: Bytes!

  " Timestamp of the block in which the Accounting engine was last modified [seconds] "
  modifiedAt: BigInt

  " Block number in which the Accounting engine was last modified "
  modifiedAtBlock: BigInt

  " Transaction hash in which the Accounting engine was last modified "
  modifiedAtTransaction: Bytes
}

# --- Balances & Deposits/Withdrawals ---

type InternalCollateralBalance @entity {
  " Equals to: <accountHandler>-<CollateralType> "
  id: ID!

  " Account ownership at the Safeengine level "
  accountHandler: Bytes!

  " Ultimate owner of the balance (The accountHandler or the Proxy)"
  owner: User!

  " Collateral type of the balance "
  collateralType: CollateralType!

  " Proxy address if the balance belongs to a proxy "
  proxy: UserProxy

  " Actual balance "
  balance: BigDecimal!

  " List of Collateral Joins (= deposits)"
  joins: [CollateralJoin!]

  " List of Collateral Exits (= withdrawals)"
  exits: [CollateralExit!]

  " Timestamp of the block in which this Safe was opened [seconds] "
  createdAt: BigInt!

  " Block number in which this Safe was opened "
  createdAtBlock: BigInt!

  " Transaction hash in which this Safe was opened "
  createdAtTransaction: Bytes!

  " Timestamp of the block in which this Safe was last modified [seconds] "
  modifiedAt: BigInt

  " Block number in which this Safe was last modified "
  modifiedAtBlock: BigInt

  " Transaction hash in which this Safe was last modified "
  modifiedAtTransaction: Bytes
}

type InternalBondBalance @entity {
  " Equals to: <accountHandler> "
  id: ID!

  " Account ownership at the Safeengine level "
  accountHandler: Bytes!

  " Ultimate owner of the balance (The accountHandler or the Proxy)"
  owner: User!

  " Proxy address if the balance belongs to a proxy "
  proxy: UserProxy

  " Actual balance "
  balance: BigDecimal!

  " List of Collateral Joins (= deposits)"
  joins: [CoinJoin!]

  " List of Collateral Exits (= withdrawals)"
  exits: [CoinExit!]

  " Timestamp of the block in which this balance was first created [seconds] "
  createdAt: BigInt!

  " Block number in which this balance was first created "
  createdAtBlock: BigInt!

  " Transaction hash in which this balance was first created "
  createdAtTransaction: Bytes!

  " Timestamp of the block in which this balance was last modified [seconds] "
  modifiedAt: BigInt

  " Block number in which this balance was last modified "
  modifiedAtBlock: BigInt

  " Transaction hash in which this balance was last modified "
  modifiedAtTransaction: Bytes
}

type InternalDebtBalance @entity {
  " Equals to: <accountHandler> "
  id: ID!

  " Account ownership at the Safeengine level "
  accountHandler: Bytes!

  " Ultimate owner of the balance (The accountHandler or the Proxy)"
  owner: User!

  " Actual balance "
  balance: BigDecimal!

  " Timestamp of the block in which this Safe was opened [seconds] "
  createdAt: BigInt!

  " Block number in which this Safe was opened "
  createdAtBlock: BigInt!

  " Transaction hash in which this Safe was opened "
  createdAtTransaction: Bytes!

  " Timestamp of the block in which this Safe was last modified [seconds] "
  modifiedAt: BigInt

  " Block number in which this Safe was last modified "
  modifiedAtBlock: BigInt

  " Transaction hash in which this Safe was last modified "
  modifiedAtTransaction: Bytes
}

type CollateralJoin @entity {
  "<TX hash>-<Log index>"
  id: ID!

  " Join amount "
  amount: BigDecimal!

  " Safe handler being credited "
  safeHandler: Bytes!

  " Owner of the safeHandler "
  owner: User!

  " Source address of the collateral"
  source: Bytes!

  " Collateral type of the Join "
  collateralType: CollateralType!

  " Timestamp of the block in which this Safe was opened [seconds] "
  createdAt: BigInt!

  " Block number in which this Safe was opened "
  createdAtBlock: BigInt!

  " Transaction hash in which this Safe was opened "
  createdAtTransaction: Bytes!
}

type CollateralExit @entity {
  "<TX hash>-<Log index>"
  id: ID!

  " Exit amount "
  amount: BigDecimal!

  " Owner of the safeHandler "
  safeHandler: Bytes

  " Owner of the safeHandler "
  owner: User!

  " Account receiving the collateral "
  recipient: Bytes!

  " Collateral type of the Exit "
  collateralType: CollateralType!

  " Timestamp of the block in which this Safe was opened [seconds] "
  createdAt: BigInt!

  " Block number in which this Safe was opened "
  createdAtBlock: BigInt!

  " Transaction hash in which this Safe was opened "
  createdAtTransaction: Bytes!
}

type CoinJoin @entity {
  "<TX hash>-<Log index>"
  id: ID!

  " Join amount "
  amount: BigDecimal!

  " Safe handler being credited "
  safeHandler: Bytes!

  " Owner of the safeHandler "
  owner: User!

  " Source address of the coins"
  source: Bytes!

  " Timestamp of the block in which this Safe was opened [seconds] "
  createdAt: BigInt!

  " Block number in which this Safe was opened "
  createdAtBlock: BigInt!

  " Transaction hash in which this Safe was opened "
  createdAtTransaction: Bytes!
}

type CoinExit @entity {
  "<TX hash>-<Log index>"
  id: ID!

  " Exit amount "
  amount: BigDecimal!

  " Safe handler owning the balance at the SAFEEninge level "
  safeHandler: Bytes!

  " Owner of the safeHandler "
  owner: User!

  " Account receiving the coins "
  recipient: Bytes!

  " Timestamp of the block in which this Safe was opened [seconds] "
  createdAt: BigInt!

  " Block number in which this Safe was opened "
  createdAtBlock: BigInt!

  " Transaction hash in which this Safe was opened "
  createdAtTransaction: Bytes!
}

# --- Prices ---
# TODO: Do not use block as ID (Can be several update per block)

type CollateralPrice @entity {
  " Equals to: <block_number>-<collateral_type>"
  id: ID!

  " Block number "
  block: BigInt!

  " Timestamp in seconds "
  timestamp: BigInt!

  " Collateral type "
  collateral: CollateralType!

  " Price of the collateral discounted by the redemptionPrice and safetyCRatio, price used for bonds mint and redemption "
  safetyPrice: BigDecimal!

  " Price of the collateral discounted by the redemptionPrice an liquidationCRatio, price at which a safe gets liquidated "
  liquidationPrice: BigDecimal!

  " Collateral price in USD "
  value: BigDecimal!
}

type RedemptionPrice @entity {
  " Equals to: <block_number>"
  id: ID!

  " Block number "
  block: BigInt!

  " Timestamp in seconds "
  timestamp: BigInt!

  " Rate of change of the redemption price, output from the feedback mechanism"
  redemptionRate: BigDecimal!

  " Value of the redemption price, the price of redemption of a reflex bond"
  value: BigDecimal!
}

type RedemptionRate @entity {
  " Equals to: <block_number>"
  id: ID!

  " Block number "
  block: BigInt!

  " Timestamp in seconds "
  timestamp: BigInt!

  " Reflex bond price for redemption "
  redemptionPrice: BigDecimal!

  " Rate of change of the redemption price, output from the feedback mechanism"
  value: BigDecimal!
}

# --- Auctions ---

enum AuctionType {
  ENGLISH
  FIXED_DISCOUNT
}

type EnglishAuctionConfiguration @entity {
  " Collateral type name OR 'DEBT' OR 'SURPLUS_PRE' OR 'SURPLUS_POST' "
  id: ID!

  " Collateral type"
  LIQUIDATION_collateralType: CollateralType

  " Minimum bid increase ratio i.g: 1.05 means 5% bid increase minimum "
  bidIncrease: BigDecimal!

  " How long the auction lasts after a new bid is submitted "
  bidDuration: BigInt

  " Maximum auction length "
  totalAuctionLength: BigInt!

  " Minimum mandatory size of the first bid compared to collateral price coming from the oracle "
  LIQUIDATION_bidToMarketPriceRatio: BigDecimal

  " OSM contract"
  LIQUIDATION_osm: Bytes

  " Oracle relayer contract "
  LIQUIDATION_oracleRelayer: Bytes

  " Amount sold increased upon auction restart (Debt auction only) "
  DEBT_amountSoldIncrease: BigDecimal
}

type EnglishAuctionBid @entity {
  "<collateral type id OR 'DEBT' OR 'SURPLUS_PRE' OR 'SURPLUS_POST'>-<auction id>-<bid number>"
  id: ID!

  " Incremental id of the bid "
  bidNumber: BigInt!

  " Type, either increase buy or decrease sell "
  type: EnglishBidType!

  " Auction to which the bid belongs if it's a bid on a collateral auction"
  auction: EnglishAuction

  " How many token we are selling in the auction "
  sellAmount: BigDecimal!

  " How many token we are buying in the auction "
  buyAmount: BigDecimal!

  " Collateral price ( sellAmount / buyAMount ) "
  price: BigDecimal!

  " Bidder address"
  bidder: Bytes

  " Timestamp of the block in which the liquidation was started "
  createdAt: BigInt!

  " Block number in which the liquidation was started "
  createdAtBlock: BigInt!

  " Transaction hash in which tthe liquidation was started "
  createdAtTransaction: Bytes!
}

# --- English Auction ---

enum EnglishAuctionType {
  LIQUIDATION
  DEBT
  SURPLUS_PRE
  SURPLUS_POST
}

enum AuctionToken {
  BOND
  COLLATERAL
  PROTOCOL_TOKEN
}

enum EnglishBidType {
  INCREASE_BUY
  DECREASE_SOLD
}

type EnglishAuction @entity {
  " <collateral type OR 'DEBBT' OR 'SURPLUS_PRE' OR 'SURPLUS_POST'>-<auction id> "
  id: ID!

  " Auction incrmental id per collateral "
  auctionId: BigInt!

  " Whether it's a liquidation, surplus auction or debt auction "
  englishAuctionType: EnglishAuctionType!

  " Token being sold "
  sellToken: AuctionToken!

  " Token being bought "
  buyToken: AuctionToken!

  " Amount of token that the system is selling a the start of the auction  "
  sellInitialAmount: BigDecimal!

  " Amount of token that the system is buying a the start of the auction  "
  buyInitialAmount: BigDecimal!

  " Amount of token that the system is currently selling in the auction "
  sellAmount: BigDecimal!

  " Amount of token that the system is currently buying in the auction "
  buyAmount: BigDecimal!

  " Sell price ( sellAmount / buyAMount ) of the best offer "
  price: BigDecimal

  " For collateral auctions only! Threshold of buyToken between which the system increase the amount of buyToken and which it start to drecrease to amount of sellToken "
  targetAmount: BigDecimal

  " Auction winner "
  winner: Bytes

  " Address that started the auction "
  startedBy: Bytes!

  " If the bough Tokens was claimed by the auction winner "
  isClaimed: Boolean!

  " Total number of bids "
  numberOfBids: BigInt!

  " Deadline for the auction after which no more bids can be placed. Note: A new bid can postpone the deadline  "
  auctionDeadline: BigInt!

  " List of individual bid "
  englishAuctionBids: [EnglishAuctionBid!] @derivedFrom(field: "auction")

  " Auction configuration "
  englishAuctionConfiguration: EnglishAuctionConfiguration!

  " Liquidation only! Safe that got liquidated "
  safe: Safe

  " Timestamp of the block in which the liquidation was started "
  createdAt: BigInt!

  " Block number in which the liquidation was started "
  createdAtBlock: BigInt!

  " Transaction hash in which tthe liquidation was started "
  createdAtTransaction: Bytes!
}

# --- Fix Discount Auction ---

type FixDiscountAuctionConfiguration @entity {
  " Collateral type name "
  id: ID!

  " Collateral type"
  collateralType: CollateralType!

  " Minimum acceptable bid "
  minimumBid: BigDecimal!

  " Total length of the auction "
  totalAuctionLength: BigInt!

  " Discount (compared to the system coin's current redemption price) at which collateral is being sold "
  discount: BigDecimal!

  " Max lower bound deviation that the collateral median can have compared to the OSM price "
  lowerCollateralMedianDeviation: BigDecimal!

  " Max upper bound deviation that the collateral median can have compared to the OSM price "
  upperCollateralMedianDeviation: BigDecimal!

  " Max lower bound deviation that the system coin oracle price feed can have compared to the OSM price "
  lowerSystemCoinMedianDeviation: BigDecimal!

  " Max upper bound deviation that the collateral median can have compared to the OSM price "
  upperSystemCoinMedianDeviation: BigDecimal!

  " Min deviation for the system coin median result compared to the redemption price in order to take the median into account "
  minSystemCoinMedianDeviation: BigDecimal!

  " Oracle relayer contract "
  oracleRelayer: Bytes

  " Collateral OSM contract address "
  collateralOSM: Bytes

  " Collateral Medianizer contract "
  collateralMedian: Bytes

  " Bond price Medianizer contract "
  systemCoinOracle: Bytes
}

type FixDiscountAuction @entity {
  " <Collateral type>-<auction ID> "
  id: ID!

  " Auction incremental id per collateral "
  auctionId: BigInt!

  " Collateral type of the auction "
  collateralType: CollateralType!

  " Safe handler address in the Safe engine "
  safeHandler: Bytes!

  " Total collateral for sale a the start of the auction "
  sellInitialAmount: BigDecimal!

  " Max amount of bond to raise with the sale of the collateral. After reaching this target, any collateral if returned to the Safe owner  "
  amountToRaise: BigDecimal!

  " Amount raised so far to repay the debt. "
  buyAmount: BigDecimal!

  " Cumulative collateral amount sold so far.  collateralAmountSold <= initialCollateralAmount"
  sellAmount: BigDecimal

  " Liquidated Safe "
  safe: Safe!

  " Hard deadline for the auction after which no more bids can be placed  "
  auctionDeadline: BigInt!

  " Address that started the auction "
  startedBy: Bytes!

  " Number of individual batch sold "
  numberOfBatches: BigInt!

  # " List of individual batches sold "
  batchSold: [FixDiscountAuctionBatch!] @derivedFrom(field: "auction")

  " Auction configuration "
  fixDiscountAuctionConfiguration: FixDiscountAuctionConfiguration!

  " If there is still collateral to be bought in the auction "
  isTerminated: Boolean!

  " Timestamp of the block in which the liquidation was started "
  createdAt: BigInt!

  " Block number in which the liquidation was started "
  createdAtBlock: BigInt!

  " Transaction hash in which tthe liquidation was started "
  createdAtTransaction: Bytes!
}

type FixDiscountAuctionBatch @entity {
  " <collateral type>-<auction id>-<batch number> "
  id: ID!

  " Incremental id of the batch "
  batchNumber: BigInt!

  " Auction in which the batch was sold "
  auction: FixDiscountAuction!

  " bonds bought in the batch "
  buyAmount: BigDecimal!

  " collateral sold in the batch "
  sellAmount: BigDecimal!

  " Collateral price "
  price: BigDecimal!

  " Bidder address"
  buyer: Bytes!

  " Timestamp of the block in which the liquidation was started "
  createdAt: BigInt!

  " Block number in which the liquidation was started "
  createdAtBlock: BigInt!

  " Transaction hash in which tthe liquidation was started "
  createdAtTransaction: Bytes!
}
